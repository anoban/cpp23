#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <new>

#include <sal.h>

#define __TO_WSTR__(expression) L##expression           // helper that actually does the job
#define TO_WSTR(expression)     __TO_WSTR__(expression) // client facing macro

#if __cplusplus < 201103L // standards prior to C++11
    #define __noexcept__ throw()
#elif __cplusplus >= 201103L // C++11 or later
    #define __noexcept__ noexcept
    #undef NULL
    #define NULL nullptr
#endif

#if (defined(__GNUG__) && defined(__GNUC__)) || (defined(__llvm__) && defined(__clang__))
    #define FUNCTIONW TO_WSTR(__PRETTY_FUNCTION__)
#elif defined(_MSC_VER) && defined(_MSC_FULL_VER) // LLVM also uses MSVC's STL headers, hence the #elif block
    #define FUNCTIONW TO_WSTR(__FUNCSIG__)
#endif

// a super trivial string class with no non-trivial optimizations whatsoever
class sstring {
    private:
        unsigned _size;     // does not count the null terminator
        unsigned _capacity; // at construction, capacity will usually be twice the size of the string
        char*    _resource; // string buffer

    public:
        inline sstring() __noexcept__ : _size(0), _capacity(0), _resource(NULL) { } // default ctor

        inline sstring(_In_ const char& ch, _In_ const unsigned long& repeats) __noexcept__ :
            _size(repeats),
            _capacity(repeats * 2),
            _resource(new (std::nothrow) char[_capacity]) {
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return; // leaves an empty sstring skeleton
            }

            ::memset(_resource, 0U, _capacity); // zero out the whole buffer
            ::memset(_resource, ch, repeats);
        }

        inline sstring(_In_ const char* const str) __noexcept__ : // NOLINT(google-explicit-constructor) - a converting constructor
            _size(::strlen(str)), _capacity(_size * 2 + 1), _resource(new (std::nothrow) char[_capacity]) {
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, str);
        }

        inline sstring(_In_ const sstring& other) __noexcept__ : // not exactly a trivial copy constructor
            _size(other._size), _capacity(other._size * 2 + 1/* choosing not to simply use the other string's capacity */), _resource(new (std::nothrow) char[_capacity]) {
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
        }

        // optimizations like buffer reuse are deliberately ignored :(
        inline sstring& operator=(_In_ const sstring& other) __noexcept__ {
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size     = other._size;
            _capacity = other._size * 2 + 1; // choosing not to simply use the other string's capacity
            _resource = new (std::nothrow) char[_capacity];

            if (!_resource) { // has the allocation failed,
                _size = _capacity = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return *this;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
            return *this;
        }

#if (__cplusplus >= 201103L) // implement move semantics

        // move ctor
        inline sstring(_Inout_ sstring&& other) __noexcept__ : _size(other._size), _capacity(other._capacity), _resource(other._resource) {
            other._resource = nullptr;
            other._size = other._capacity = 0;
        }

        // move assignment operator
        inline sstring& operator=(_Inout_ sstring&& other) __noexcept__ {
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size           = other._size;
            _capacity       = other._capacity;
            _resource       = other._resource;

            other._resource = nullptr;
            other._size = other._capacity = 0;

            return *this;
        }

#endif

        inline ~sstring() __noexcept__ {
            delete[] _resource;
            _resource = NULL;
            _size = _capacity = 0;
        }

        static inline sstring with_capacity(_In_ const unsigned long& size) __noexcept__ { // a Rust style static ctor
            sstring temporary;
            temporary._resource = new (std::nothrow) char[size];
            if (!temporary._resource) { // has the allocation failed,
                ::fputws(L"allocation failure!\n", stderr);
                return temporary;
            }

            temporary._capacity = size; // temporary._size will be 0
            return temporary;
        }

        inline size_t length() const __noexcept__ { return _size; }

        inline size_t capacity() const __noexcept__ { return _capacity; }

        inline char* c_str() __noexcept__ { return _resource; }

        inline const char* c_str() const __noexcept__ { return _resource; }

        sstring operator+(_In_ const sstring& other) const __noexcept__ { }

        sstring operator+=(_In_ const sstring& other) const __noexcept__ { }
};

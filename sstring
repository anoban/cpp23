#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <new>

#include <sal.h> // to please g++

#ifndef LPREFIX
    #define LPREFIX(expression) L"" expression // relies on automatic concatenation of adjacent string literals
#endif

#define __TO_WSTR__(expanded_macro) L##expanded_macro       // helper that actually does the token pasting
#define TO_WSTR(expression)         __TO_WSTR__(expression) // client facing macro

// in LLVM and GCC, __FUNCTION__ and __PRETTY_FUNCTION__ are variables NOT MACROS!
// in MSVC, __FUNCSIG__ expands as a MACRO (Microsoft extension)

#if __cplusplus < 201103L // standards prior to C++11
    #define noexcept throw()
    #define nullptr  NULL        // replace nullptr with NULL
typedef unsigned long size_type; // C++98 did not support long long types
#else                            // C++11 or later
using size_type = unsigned long long;
#endif

#if (defined(__GNUG__) && defined(__GNUC__)) || (defined(__llvm__) && defined(__clang__)) // with g++/clang++/icx
    // fall back to using the variable __PRETTY_FUNCTION__
#elif defined(_MSC_VER) && defined(_MSC_FULL_VER) // LLVM also uses MSVC's STL headers, hence the nesting inside #elif block
    #define __PRETTY_FUNCTION__ __FUNCSIG__
#endif

namespace __sstring_internals {

    // resorting to runtime conversion :(
    static inline const wchar_t* wsignature(_In_ const char* _cxx_signature) noexcept {
        static const unsigned _signature_length = 512;
        static wchar_t        _signature[_signature_length]; // NOLINT(modernize-avoid-c-arrays)

        unsigned charcount = 0;
        ::memset(_signature, 0U, _signature_length * sizeof(wchar_t));
        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic,cppcoreguidelines-pro-bounds-constant-array-index)
        while (*_cxx_signature) _signature[charcount++] = *_cxx_signature++;
        assert(charcount <= _signature_length);
        return _signature;
    }

} // namespace __sstring_internals

// a super trivial string class with NO NON-TRIVIAL OPTIMIZATIONS whatsoever
class sstring {
    private:
        size_type _size;     // does not count the null terminator
        size_type _capacity; // at construction, capacity will usually be twice the size of the string
        char*     _resource; // string buffer

    public:
        inline __cdecl sstring() noexcept : _size(0), _capacity(0), _resource(nullptr) { // default ctor
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
        }

        inline __cdecl sstring(_In_ const char& ch, _In_ const size_type& repeats) noexcept :
            _size(repeats), _capacity(repeats * 2), _resource(new (std::nothrow) char[_capacity]) {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return; // leaves an empty sstring skeleton
            }

            ::memset(_resource, 0U, _capacity); // zero out the whole buffer
            ::memset(_resource, ch, repeats);
        }

        inline __cdecl sstring(_In_ const char* const str) noexcept : // NOLINT(google-explicit-constructor) - a converting constructor
            _size(::strlen(str) + 1 /* +1 for the null terminator */),
            _capacity(_size * 2 + 1),
            _resource(new (std::nothrow) char[_capacity]) {
            // using ::strlen(str) here and using _size + 1 in strcpy_s will bite us in the ass when trying to copy or move
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, str);
        }

        inline __cdecl sstring(_In_ const sstring& other) noexcept : // not exactly a trivial copy constructor
            _size(other._size),
            _capacity(other._size * 2 + 1 /* choosing not to simply use the other string's capacity */),
            _resource(new (std::nothrow) char[_capacity]) {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
        }

        // optimizations like buffer reuse are deliberately ignored :(
        inline sstring& __cdecl operator=(_In_ const sstring& other) noexcept {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size     = other._size;
            _capacity = other._size * 2 + 1; // choosing not to simply use the other string's capacity
            _resource = new (std::nothrow) char[_capacity];

            if (!_resource) { // has the allocation failed,
                _size = _capacity = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return *this;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
            return *this;
        }

#if (__cplusplus >= 201103L) // implement move semantics

        // move ctor
        inline __cdecl sstring(_Inout_ sstring&& other) noexcept :
            _size(other._size), _capacity(other._capacity), _resource(other._resource) {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            other._resource = nullptr;
            other._size = other._capacity = 0;
        }

        // move assignment operator
        inline sstring& __cdecl operator=(_Inout_ sstring&& other) noexcept {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size           = other._size;
            _capacity       = other._capacity;
            _resource       = other._resource;

            other._resource = nullptr;
            other._size = other._capacity = 0;

            return *this;
        }

#endif

        inline __cdecl ~sstring() noexcept {
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            delete[] _resource;
            _resource = nullptr;
            _size = _capacity = 0;
        }

        static inline sstring __cdecl with_capacity(_In_ const size_type& size) noexcept { // a Rust style static ctor
            ::_putws(__sstring_internals::wsignature(__PRETTY_FUNCTION__));
            sstring temporary;
            temporary._resource = new (std::nothrow) char[size];
            if (!temporary._resource) { // has the allocation failed,
                ::fputws(L"allocation failure!\n", stderr);
                return temporary;
            }

            temporary._capacity = size; // temporary._size will be 0
            return temporary;
        }

        inline size_type __stdcall length() const noexcept { return _size; }

        inline size_type __stdcall capacity() const noexcept { return _capacity; }

        inline char* __cdecl c_str() noexcept { return _resource; }

        inline const char* __cdecl c_str() const noexcept { return _resource; }

        // operator usable for lvalues and rvalues for operands
        sstring __cdecl operator+(_In_ const sstring& other) const noexcept {
            sstring temporary;
            temporary._resource = new (std::nothrow) char[(_size + other._size) * 2]; // has space for 2 null terminators
            if (!temporary._resource) {                                               // has the allocation failed,
                ::fputws(L"allocation failure!\n", stderr);
                return temporary;
            }

            temporary._size     = _size + other._size - 1; // remove the null terminator of the first string
            temporary._capacity = (_size + other._size) * 2;

            ::memset(temporary._resource, 0U, temporary._capacity);
            ::strcpy_s(temporary._resource, _size, _resource); // copy this buffer
            ::strcpy_s(
                temporary._resource + _size - 1 /* start @ the null terminator of the first string */, other._size, other._resource
            ); // copy other's buffer
            return temporary;
        }

        // operator usable only with lvalue left operand
        sstring& __cdecl operator+=(_In_ const sstring& other) noexcept { }

        friend inline std::ostream& __cdecl operator<<(std::ostream& ostream, const sstring& string) noexcept {
            ostream << string.c_str();
            return ostream;
        }
};

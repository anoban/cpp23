#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <new>

#include <sal.h> // to please g++

#define __TO_WSTR__(expanded_macro) L##expanded_macro       // helper that actually does the token pasting
#define TO_WSTR(expression)         __TO_WSTR__(expression) // client facing macro

// in LLVM and GCC, __FUNCTION__ and __PRETTY_FUNCTION__ are variables NOT MACROS!
// in MSVC __FUNCSIG__ is indeed a MACRO

#ifndef __LPREFIX
    #define __LPREFIX(expression) L"" expression // relies on automatic concatenation of adjacent string literals
#endif

static constexpr auto fname { __LPREFIX(__FILE__) };
static constexpr auto filename { TO_WSTR(__FILE__) }; // both do the job fine :)

#if __cplusplus < 201103L // standards prior to C++11
    #define __noexcept__ throw()
#elif __cplusplus >= 201103L // C++11 or later
    #define __noexcept__ noexcept
    #undef NULL
    #define NULL nullptr // replace NULL with nullptr
#endif

// with g++/clang++/icx
#if defined(__GNUG__) && defined(__GNUC__)
    #pragma message("compiling using g++")
    #define FUNC_FULL_NAME __LPREFIX(__PRETTY_FUNCTION__)
#elif defined(__llvm__) && defined(__clang__)
    #pragma message("compiling using clang++")
    #define FUNC_FULL_NAME __LPREFIX(__PRETTY_FUNCTION__)
#elif defined(_MSC_VER) && defined(_MSC_FULL_VER) // LLVM also uses MSVC's STL headers, hence the nesting inside #elif block
    #pragma message("compiling using MSVC++")
    #define FUNC_FULL_NAME TO_WSTR(__FUNCSIG__)
#endif

// a super trivial string class with no non-trivial optimizations whatsoever
class sstring {
    private:
        unsigned _size;     // does not count the null terminator
        unsigned _capacity; // at construction, capacity will usually be twice the size of the string
        char*    _resource; // string buffer

    public:
        inline __cdecl sstring() __noexcept__ : _size(0), _capacity(0), _resource(NULL) { // default ctor
            ::_putws(FUNC_FULL_NAME);
        }

        inline __cdecl sstring(_In_ const char& ch, _In_ const unsigned long& repeats) __noexcept__ :
            _size(repeats),
            _capacity(repeats * 2),
            _resource(new (std::nothrow) char[_capacity]) {
            ::_putws(FUNC_FULL_NAME);
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return; // leaves an empty sstring skeleton
            }

            ::memset(_resource, 0U, _capacity); // zero out the whole buffer
            ::memset(_resource, ch, repeats);
        }

        inline __cdecl sstring(_In_ const char* const str) __noexcept__ : // NOLINT(google-explicit-constructor) - a converting constructor
            _size(::strlen(str) + 1 /* +1 for the null terminator */), _capacity(_size * 2 + 1), _resource(new (std::nothrow) char[_capacity]) {
            // using ::strlen(str) here and using _size + 1 in strcpy_s will bite us in the ass when trying to copy or move
            ::_putws(FUNC_FULL_NAME);
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, str);
        }

        inline __cdecl sstring(_In_ const sstring& other) __noexcept__ : // not exactly a trivial copy constructor
            _size(other._size), _capacity(other._size * 2 + 1/* choosing not to simply use the other string's capacity */), _resource(new (std::nothrow) char[_capacity]) {
            ::_putws(FUNC_FULL_NAME);
            if (!_resource) { // has the allocation failed,
                _capacity = _size = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
        }

        // optimizations like buffer reuse are deliberately ignored :(
        inline sstring& __cdecl operator=(_In_ const sstring& other) __noexcept__ {
            ::_putws(FUNC_FULL_NAME);
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size     = other._size;
            _capacity = other._size * 2 + 1; // choosing not to simply use the other string's capacity
            _resource = new (std::nothrow) char[_capacity];

            if (!_resource) { // has the allocation failed,
                _size = _capacity = 0;
                ::fputws(L"allocation failure!\n", stderr);
                return *this;
            }

            ::memset(_resource, 0U, _capacity);
            ::strcpy_s(_resource, _size, other._resource);
            return *this;
        }

#if (__cplusplus >= 201103L) // implement move semantics

        // move ctor
        inline __cdecl sstring(_Inout_ sstring&& other) noexcept :
            _size(other._size), _capacity(other._capacity), _resource(other._resource) {
            ::_putws(FUNC_FULL_NAME);
            other._resource = nullptr;
            other._size = other._capacity = 0;
        }

        // move assignment operator
        inline sstring& __cdecl operator=(_Inout_ sstring&& other) noexcept {
            ::_putws(FUNC_FULL_NAME);
            if (this == &other) return *this;

            delete[] _resource; // give up the old buffer
            _size           = other._size;
            _capacity       = other._capacity;
            _resource       = other._resource;

            other._resource = nullptr;
            other._size = other._capacity = 0;

            return *this;
        }

#endif

        inline __cdecl ~sstring() __noexcept__ {
            ::_putws(FUNC_FULL_NAME);
            delete[] _resource;
            _resource = NULL;
            _size = _capacity = 0;
        }

        static inline sstring __cdecl with_capacity(_In_ const unsigned long& size) __noexcept__ { // a Rust style static ctor
            ::_putws(FUNC_FULL_NAME);
            sstring temporary;
            temporary._resource = new (std::nothrow) char[size];
            if (!temporary._resource) { // has the allocation failed,
                ::fputws(L"allocation failure!\n", stderr);
                return temporary;
            }

            temporary._capacity = size; // temporary._size will be 0
            return temporary;
        }

        inline size_t __stdcall length() const __noexcept__ { return _size; }

        inline size_t __stdcall capacity() const __noexcept__ { return _capacity; }

        inline char* __cdecl c_str() __noexcept__ { return _resource; }

        inline const char* __cdecl c_str() const __noexcept__ { return _resource; }

        sstring __cdecl operator+(_In_ const sstring& other) const __noexcept__ { }

        sstring& __cdecl operator+=(_In_ const sstring& other) & __noexcept__ { }

        friend inline std::ostream& __cdecl operator<<(std::ostream& ostream, const sstring& string) __noexcept__ {
            ostream << string.c_str();
            return ostream;
        }
};

// cl.exe lambdatypes.cpp /arch:AVX512 /diagnostics:caret /DNDEBUG /EHa /F0x10485100 /favor:INTEL64 /fp:strict /fpcvt:IA /GL /Gw /MP /O2 /Ob3 /Oi /Ot /Qpar /std:c++20 /TP /Wall /wd4710 /wd4711 /wd4820 /Zc:preprocessor /link /DEBUG:NONE

#include <cassert>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <type_traits>

const auto lambda_0 = [](int x, int y) consteval noexcept -> double { return x + y; };
const auto lambda_1 = [](int x, int y) consteval noexcept -> double { return x + y; };

// these two lambdas will have different types albeit having exactly same type signatures!
// the reason being the closure objects generated by the compiler from these two lamdas will be of two separate struct types
// both of them will be class types (mostly structs) but different type of structs!

#ifdef __TRYME__
static_assert(std::is_same_v<decltype(lambda_0), decltype(lambda_1)>); // NOPE!
#endif                                                                 //!__TRYME__

const std::function<double(int, int)> wrapper_0 = [](int x, int y) constexpr noexcept -> double {
    return x + y;
}; // cannot have consteval here

// unlike plain lambdas, std::function has complex internal state and could even require dynamic alloction
// hence the heftiness

struct stateless {
        constexpr long operator()() const noexcept { return 12; }
};

template<typename T> requires std::floating_point<T> [[nodiscard]] static constexpr bool is_close(T _a, T _b) throw() {
    return std::abs(_a - _b) < std::numeric_limits<T>::min();
}

// something's wrong here!
template<typename T>
[[nodiscard]] static constexpr bool is_close(typename std::enable_if<std::is_floating_point<T>::value>::type _a, T _b) throw() {
    return std::abs(_a - _b) < std::numeric_limits<T>::min();
}

int main() {
    std::wcout << L"sizeof(lambda_0) is " << sizeof(lambda_0) << L" bytes!\n";   // 1 byte
    std::wcout << L"sizeof(wrapper_0) is " << sizeof(wrapper_0) << L" bytes!\n"; // 64 bytes

    // compiler created closure objects for stateless lambdas are just empty class types with only the operator() defined!
    std::wcout << L"sizeof(stateless) is " << sizeof(stateless) << L" bytes!\n"; // 1 byte
    std::wcout << L"sizeof([] {}) is " << sizeof([] { }) << L" bytes!\n";        // 1 byte

    std::wcout << std::boolalpha << ::is_close(lambda_0(10, 56), wrapper_0.operator()(56, 10)) << L'\n';

    return EXIT_SUCCESS;
}
